<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wes.IO Live - Watch</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --accent: #7dd3fc;
            --accent-dark: #38bdf8;
            --accent-soft: rgba(125, 211, 252, 0.25);
            --pink: #f9a8d4;
            --live-red: #fb7185;
            --bg-dark: #0f172a;
            --bg-card: rgba(30, 41, 59, 0.5);
            --text-muted: #94a3b8;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        @keyframes gradient-shift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        @keyframes bubble-float {
            0%, 100% { transform: translateY(100vh) scale(0); opacity: 0; }
            10% { opacity: 0.4; }
            90% { opacity: 0.25; }
            100% { transform: translateY(-80px) scale(1); opacity: 0; }
        }
        @keyframes pulse-dot {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.1); }
        }
        @keyframes count-pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.15); }
            100% { transform: scale(1); }
        }
        @keyframes fade-in-up {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes live-badge-blink {
            0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(251, 113, 133, 0.4); }
            50% { opacity: 0.95; box-shadow: 0 0 0 6px rgba(251, 113, 133, 0); }
        }

        body {
            font-family: 'Nunito', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 40%, #0f172a 100%);
            background-size: 200% 200%;
            animation: gradient-shift 14s ease infinite;
            color: #e2e8f0;
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow-x: hidden;
        }

        .bg-bubbles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }
        .bg-bubbles span {
            position: absolute;
            bottom: -50px;
            display: block;
            width: 32px;
            height: 32px;
            background: radial-gradient(circle, var(--accent-soft) 0%, transparent 70%);
            border-radius: 50%;
            animation: bubble-float 20s linear infinite;
        }
        .bg-bubbles span:nth-child(1) { left: 8%; animation-delay: 0s; }
        .bg-bubbles span:nth-child(2) { left: 30%; animation-delay: 4s; width: 24px; height: 24px; }
        .bg-bubbles span:nth-child(3) { left: 55%; animation-delay: 2s; width: 40px; height: 40px; animation-duration: 22s; }
        .bg-bubbles span:nth-child(4) { left: 78%; animation-delay: 6s; }
        .bg-bubbles span:nth-child(5) { left: 92%; animation-delay: 3s; width: 28px; height: 28px; }

        .header {
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(12px);
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
            flex-wrap: wrap;
            gap: 12px;
            position: relative;
            z-index: 10;
            animation: fade-in-up 0.4s ease-out;
        }
        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
            min-width: 0;
        }
        .header h1 {
            font-size: 1.15rem;
            font-weight: 700;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .live-badge {
            background: linear-gradient(135deg, var(--live-red) 0%, #e11d48 100%);
            color: #fff;
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 800;
            letter-spacing: 0.04em;
            display: none;
            white-space: nowrap;
            box-shadow: 0 2px 10px rgba(251, 113, 133, 0.4);
            animation: live-badge-blink 2s ease-in-out infinite;
        }
        .live-badge.show { display: inline-block; }
        .vod-badge {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
            color: #0f172a;
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 800;
            display: none;
            white-space: nowrap;
            box-shadow: 0 2px 10px rgba(56, 189, 248, 0.35);
        }
        .vod-badge.show { display: inline-block; }
        .header-right {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }
        .btn {
            padding: 10px 18px;
            border: none;
            border-radius: 12px;
            font-size: 0.9rem;
            font-weight: 700;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            white-space: nowrap;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        .btn-secondary {
            background: rgba(255, 255, 255, 0.08);
            color: #e2e8f0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .btn-secondary:hover { background: rgba(255, 255, 255, 0.12); transform: translateY(-2px); }
        .btn-secondary:active { transform: translateY(0); }

        .main {
            display: flex;
            height: calc(100vh - 58px);
            position: relative;
            z-index: 1;
        }
        .video-section {
            flex: 1;
            padding: 16px;
            display: flex;
            flex-direction: column;
            min-width: 0;
            animation: fade-in-up 0.5s ease-out 0.1s both;
        }
        .video-container {
            flex: 1;
            background: #0f172a;
            border-radius: 16px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            min-height: 200px;
            border: 1px solid rgba(255, 255, 255, 0.06);
            box-shadow: 0 20px 40px -12px rgba(0, 0, 0, 0.4);
            transition: box-shadow 0.3s ease;
        }
        .video-container:hover {
            box-shadow: 0 20px 40px -12px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(125, 211, 252, 0.1);
        }
        #player {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .video-placeholder {
            position: absolute;
            text-align: center;
            color: var(--text-muted);
            padding: 24px;
        }
        .video-placeholder .icon {
            font-size: 3rem;
            margin-bottom: 12px;
            opacity: 0.7;
        }
        .video-placeholder .text {
            font-size: 1rem;
            font-weight: 600;
        }
        .video-placeholder .subtext {
            font-size: 0.9rem;
            margin-top: 8px;
            color: #64748b;
        }

        .room-info {
            padding: 14px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
        }
        .room-meta {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .meta-item {
            color: var(--text-muted);
            font-size: 0.9rem;
            font-weight: 600;
        }
        .meta-value {
            color: var(--accent);
            font-weight: 800;
            transition: transform 0.2s ease;
        }
        .meta-value.count-pop {
            animation: count-pop 0.4s ease;
        }

        .sidebar {
            width: 400px;
            min-width: 400px;
            background: rgba(15, 23, 42, 0.6);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-left: 1px solid rgba(255, 255, 255, 0.06);
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            animation: fade-in-up 0.5s ease-out 0.2s both;
        }
        .info-card {
            background: var(--bg-card);
            border-radius: 14px;
            padding: 16px;
            margin-bottom: 14px;
            border: 1px solid rgba(255, 255, 255, 0.06);
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .info-card:hover {
            border-color: rgba(125, 211, 252, 0.15);
        }
        .info-card h3 {
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--text-muted);
            margin-bottom: 12px;
        }
        .info-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
            gap: 12px;
        }
        .info-item:last-child { border-bottom: none; }
        .info-label { color: var(--text-muted); flex-shrink: 0; font-weight: 600; font-size: 0.85rem; }
        .info-value { color: #fff; text-align: right; word-break: break-word; font-weight: 600; }

        .status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 14px;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 700;
            white-space: nowrap;
            transition: all 0.3s ease;
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .status-waiting { background: rgba(251, 191, 36, 0.2); border: 1px solid rgba(251, 191, 36, 0.3); }
        .status-waiting .status-dot { background: #fbbf24; animation: pulse-dot 1.2s ease-in-out infinite; }
        .status-playing { background: rgba(56, 189, 248, 0.2); border: 1px solid rgba(56, 189, 248, 0.3); }
        .status-playing .status-dot { background: var(--accent-dark); }
        .status-offline { background: rgba(100, 116, 139, 0.2); border: 1px solid rgba(100, 116, 139, 0.2); }
        .status-offline .status-dot { background: #64748b; }

        .error-banner {
            background: rgba(248, 113, 113, 0.15);
            color: #fca5a5;
            padding: 14px 18px;
            margin: 16px;
            border-radius: 12px;
            display: none;
            word-break: break-word;
            font-weight: 600;
            font-size: 0.9rem;
            border: 1px solid rgba(248, 113, 113, 0.3);
            animation: fade-in-up 0.3s ease-out;
        }
        .error-banner.show { display: block; }

        .room-description {
            color: var(--text-muted);
            font-size: 0.9rem;
            line-height: 1.5;
            word-break: break-word;
        }
        .room-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }
        .tag {
            background: var(--accent-soft);
            color: var(--accent);
            padding: 5px 12px;
            border-radius: 8px;
            font-size: 0.8rem;
            font-weight: 600;
        }
        .chat-panel {
            display: flex;
            flex-direction: column;
            min-height: 420px;
            height: 480px;
        }
        .chat-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            flex-wrap: wrap;
            gap: 8px;
        }
        .btn-chat-reconnect {
            padding: 4px 10px;
            font-size: 0.75rem;
            font-weight: 700;
            border-radius: 8px;
            background: rgba(125, 211, 252, 0.2);
            color: var(--accent);
            border: 1px solid rgba(125, 211, 252, 0.4);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .btn-chat-reconnect:hover:not(:disabled) {
            background: rgba(125, 211, 252, 0.3);
            transform: translateY(-1px);
        }
        .btn-chat-reconnect:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }
        .chat-status {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-muted);
        }
        .chat-status.connected { color: var(--accent); }
        .chat-status.error {
            color: #f87171;
            cursor: pointer;
            text-decoration: underline;
            text-underline-offset: 2px;
        }
        .chat-status.error:hover { color: #fca5a5; }
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            background: rgba(15, 23, 42, 0.5);
            border-radius: 12px;
            -webkit-overflow-scrolling: touch;
            border: 1px solid rgba(255, 255, 255, 0.04);
        }
        .chat-message {
            margin-bottom: 10px;
            padding: 10px 14px;
            border-radius: 12px;
            background: rgba(30, 41, 59, 0.6);
            word-break: break-word;
            transition: transform 0.2s ease;
            animation: fade-in-up 0.25s ease-out;
        }
        .chat-message:hover { transform: translateX(2px); }
        .chat-message.own { background: rgba(56, 189, 248, 0.15); border: 1px solid rgba(56, 189, 248, 0.25); }
        .chat-message .username {
            color: var(--accent);
            font-weight: 700;
            margin-right: 8px;
            font-size: 0.9rem;
        }
        .chat-message .content { color: #e2e8f0; font-size: 0.9rem; line-height: 1.45; }
        .chat-message .time {
            color: #64748b;
            font-size: 0.75rem;
            margin-left: 8px;
        }
        .chat-input-area {
            display: flex;
            gap: 10px;
            padding-top: 12px;
        }
        .chat-input-area input {
            flex: 1;
            padding: 10px 14px;
            border: 2px solid rgba(255, 255, 255, 0.06);
            border-radius: 12px;
            background: rgba(15, 23, 42, 0.6);
            color: #fff;
            font-family: inherit;
            font-size: 0.9rem;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .chat-input-area input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 4px var(--accent-soft);
        }
        .chat-input-area input::placeholder { color: #64748b; }
        .chat-input-area button {
            padding: 10px 18px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
            color: #0f172a;
            font-weight: 700;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.25s ease;
            box-shadow: 0 4px 12px rgba(56, 189, 248, 0.3);
        }
        .chat-input-area button:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 6px 16px rgba(56, 189, 248, 0.4); }
        .chat-input-area button:disabled {
            background: #475569;
            color: #94a3b8;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .main { flex-direction: column; height: auto; min-height: calc(100vh - 58px); }
            .video-section { padding: 12px; width: 100%; }
            .video-container { height: 50vh; max-height: 400px; border-radius: 12px; }
            .sidebar {
                width: 100%;
                min-width: 0;
                border-left: none;
                border-top: 1px solid rgba(255, 255, 255, 0.06);
                padding: 12px;
                max-height: none;
            }
            .chat-panel { height: 50vh; min-height: 300px; max-height: 500px; }
        }
        @media (max-width: 480px) {
            .header { padding: 10px 12px; }
            .header h1 { font-size: 1rem; }
            .btn { padding: 8px 14px; font-size: 0.85rem; }
            .video-container { height: 40vh; max-height: 300px; }
            .video-placeholder .icon { font-size: 2.5rem; }
        }
        @media (max-width: 768px) and (orientation: landscape) {
            .video-container { height: 70vh; max-height: none; }
            .chat-panel { height: 40vh; min-height: 250px; }
        }
    </style>
</head>
<body>
    <div class="bg-bubbles">
        <span></span><span></span><span></span><span></span><span></span>
    </div>
    <header class="header">
        <div class="header-left">
            <h1 id="roomTitle">Loading...</h1>
            <span id="liveBadge" class="live-badge">LIVE</span>
            <span id="vodBadge" class="vod-badge">VOD</span>
        </div>
        <div class="header-right">
            <div id="status" class="status status-waiting">
                <span class="status-dot"></span>
                <span>Waiting for stream</span>
            </div>
            <button class="btn btn-secondary" onclick="location.href='rooms.html'">Back to rooms</button>
        </div>
    </header>

    <div id="errorBanner" class="error-banner"></div>

    <div class="main">
        <div class="video-section">
            <div class="video-container">
                <video id="player" controls autoplay playsinline></video>
                <div class="video-placeholder" id="placeholder">
                    <div class="icon">-</div>
                    <div class="text">Waiting for the host to start streaming</div>
                    <div class="subtext">Playback will start automatically when the stream begins</div>
                </div>
            </div>
            <div class="room-info">
                <div class="room-meta">
                    <div class="meta-item">
                        Viewers: <span class="meta-value" id="viewerCount">â€”</span>
                    </div>
                    <div class="meta-item">
                        Host: <span class="meta-value" id="ownerName">-</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="sidebar">
            <div class="info-card chat-panel">
                <div class="chat-header">
                    <h3>Chat</h3>
                    <span style="display: flex; align-items: center; gap: 8px;">
                        <span id="chatStatus" class="chat-status">Not connected</span>
                        <button type="button" id="chatReconnectBtn" class="btn-chat-reconnect" style="display: none;">Reconnect</button>
                    </span>
                </div>
                <div class="chat-messages" id="chatMessages"></div>
                <div class="chat-input-area">
                    <input type="text" id="chatInput" placeholder="Type a message..." maxlength="500" disabled>
                    <button id="chatSendBtn" disabled>Send</button>
                </div>
            </div>

            <div class="info-card">
                <h3>Room info</h3>
                <div id="roomDescription" class="room-description">Loading...</div>
                <div id="roomTags" class="room-tags"></div>
            </div>

            <div class="info-card">
                <h3>Connection</h3>
                <div class="info-item">
                    <span class="info-label">Signal server</span>
                    <span class="info-value" id="signalStatus">Connecting...</span>
                </div>
                <div class="info-item">
                    <span class="info-label">HLS stream</span>
                    <span class="info-value" id="hlsStatus">Waiting</span>
                </div>
            </div>

            <div class="info-card">
                <h3>Playback</h3>
                <div class="info-item">
                    <span class="info-label">Latency</span>
                    <span class="info-value">6-10 sec</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Protocol</span>
                    <span class="info-value">HLS (H.264)</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Resolution</span>
                    <span class="info-value" id="playResolution">-</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Bitrate</span>
                    <span class="info-value" id="playBitrate">-</span>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script src="js/auth.js"></script>
    <script src="js/api.js"></script>
    <script src="js/signal.js"></script>
    <script src="js/chat.js"></script>
    <script src="js/presence.js"></script>
    <script>
        // Check auth
        if (!Auth.requireAuth()) {
            throw new Error('Not authenticated');
        }

        // Safe token getter: use getValidToken if available, else getToken (avoids "getValidToken is not a function" when auth.js load fails)
        async function getAuthToken() {
            if (typeof Auth !== 'undefined' && typeof Auth.getValidToken === 'function') {
                return await Auth.getValidToken();
            }
            if (typeof Auth !== 'undefined' && typeof Auth.getToken === 'function') {
                return Auth.getToken();
            }
            return null;
        }

        // Get URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const roomId = urlParams.get('room');
        const isVOD = urlParams.get('vod') === 'true';
        const vodSessionId = urlParams.get('session');

        if (!roomId) {
            alert('Missing room ID');
            window.location.href = 'rooms.html';
            throw new Error('Missing room ID');
        }

        // DOM elements
        const player = document.getElementById('player');
        const placeholder = document.getElementById('placeholder');
        const liveBadge = document.getElementById('liveBadge');
        const vodBadge = document.getElementById('vodBadge');
        const errorBanner = document.getElementById('errorBanner');
        const chatStatusEl = document.getElementById('chatStatus');
        const chatMessagesEl = document.getElementById('chatMessages');
        const chatInputEl = document.getElementById('chatInput');
        const chatSendBtn = document.getElementById('chatSendBtn');
        const chatReconnectBtn = document.getElementById('chatReconnectBtn');

        // State
        let hls = null;
        let isPlaying = false;
        let hlsUrl = '';
        let qualityInterval = null;
        let chatSessionId = null;
        let chatJoined = false;
        let chatInitialized = false;
        let vodChatTimeline = [];
        let vodChatIndex = 0;
        let lastChatTime = 0;
        let vodChatEnabled = false;

        // Status functions
        function setStatus(status, text) {
            const statusEl = document.getElementById('status');
            statusEl.className = `status status-${status}`;
            statusEl.querySelector('span:last-child').textContent = text;
        }

        /** Format any error into a displayable string, avoid [object Error] */
        function formatError(err) {
            if (err == null) return 'Unknown error';
            if (typeof err === 'string') return err;
            if (err && typeof err.message === 'string' && err.message) return err.message;
            if (err && err.constructor && err.constructor.name === 'Event') {
                return (err.type && err.type !== 'error') ? `Event: ${err.type}` : 'Connection error';
            }
            try {
                const s = err.toString && err.toString();
                if (s && s !== '[object Object]') return s;
            } catch (e) {}
            try {
                return JSON.stringify(err);
            } catch (e) {}
            return String(err);
        }

        function showError(message) {
            errorBanner.textContent = typeof message === 'string' ? message : formatError(message);
            errorBanner.classList.add('show');
        }

        function hideError() {
            errorBanner.classList.remove('show');
        }

        function updateInfo(id, value) {
            document.getElementById(id).textContent = value;
        }

        /** Update viewer count (live) and trigger number change animation */
        function updateViewerCount(count) {
            const el = document.getElementById('viewerCount');
            if (!el) return;
            const num = typeof count === 'number' ? count : (parseInt(count, 10) || 0);
            el.textContent = num;
            el.classList.remove('count-pop');
            void el.offsetWidth; // reflow
            el.classList.add('count-pop');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function updateChatStatus(text, className = '') {
            chatStatusEl.textContent = text;
            chatStatusEl.className = `chat-status ${className}`.trim();
            if (className.includes('error') && chatSessionId && chatReconnectBtn) {
                chatReconnectBtn.style.display = 'inline-block';
            }
        }

        function enableChatInput(enabled) {
            chatInputEl.disabled = !enabled;
            chatSendBtn.disabled = !enabled;
        }

        function scrollChatToBottom() {
            chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
        }

        function formatMessageTime(message) {
            const raw = message.timestamp || message.created_at;
            const date = raw ? new Date(raw) : new Date();
            if (Number.isNaN(date.getTime())) {
                return '';
            }
            return date.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        function appendChatMessage(message, shouldScroll = true) {
            const item = document.createElement('div');
            const isOwn = message.user_id && message.user_id === Chat.getState().userId;
            item.className = `chat-message${isOwn ? ' own' : ''}`;

            const timeText = formatMessageTime(message);
            item.innerHTML = `
                <span class="username">${escapeHtml(message.username || 'Unknown')}</span>
                <span class="content">${escapeHtml(message.content || '')}</span>
                <span class="time">${timeText}</span>
            `;

            chatMessagesEl.appendChild(item);
            if (shouldScroll) {
                scrollChatToBottom();
            }
        }

        function parseSessionIdFromHls(hlsUrlValue) {
            if (!hlsUrlValue) return '';
            try {
                const url = new URL(hlsUrlValue, window.location.origin);
                const parts = url.pathname.split('/');
                if (parts.length >= 4 && parts[1] === 'live') {
                    return parts[3];
                }
            } catch (e) {
                console.warn('Failed to parse HLS URL:', e);
            }
            return '';
        }

        function parseSessionIdToDate(sessionIdValue) {
            if (!sessionIdValue) return null;
            const normalized = sessionIdValue.replace(
                /^(\d{4}-\d{2}-\d{2})T(\d{2})-(\d{2})-(\d{2})Z$/,
                '$1T$2:$3:$4Z'
            );
            const date = new Date(normalized);
            if (Number.isNaN(date.getTime())) return null;
            return date;
        }

        function resetVODChatPlayback() {
            vodChatIndex = 0;
            lastChatTime = 0;
            chatMessagesEl.innerHTML = '';
        }

        function renderVODChatUpTo(timeSeconds) {
            if (!vodChatEnabled || vodChatTimeline.length === 0) return;

            if (timeSeconds < lastChatTime - 2) {
                resetVODChatPlayback();
                while (vodChatIndex < vodChatTimeline.length &&
                    vodChatTimeline[vodChatIndex].offset <= timeSeconds) {
                    appendChatMessage(vodChatTimeline[vodChatIndex].message, false);
                    vodChatIndex++;
                }
                scrollChatToBottom();
                lastChatTime = timeSeconds;
                return;
            }

            while (vodChatIndex < vodChatTimeline.length &&
                vodChatTimeline[vodChatIndex].offset <= timeSeconds + 0.5) {
                appendChatMessage(vodChatTimeline[vodChatIndex].message, true);
                vodChatIndex++;
            }

            lastChatTime = timeSeconds;
        }

        async function loadChatHistory() {
            if (!chatSessionId) return;
            try {
                const response = await API.Chat.getHistory(roomId, chatSessionId, {
                    limit: 50,
                    direction: 'backward'
                });

                if (response && response.success && response.data && response.data.messages) {
                    const messages = response.data.messages.slice().reverse();

                    if (isVOD) {
                        const sessionStart = parseSessionIdToDate(chatSessionId);
                        if (sessionStart) {
                            vodChatEnabled = true;
                            vodChatTimeline = messages
                                .map(msg => {
                                    const createdAt = msg.created_at ? new Date(msg.created_at) : null;
                                    if (!createdAt || Number.isNaN(createdAt.getTime())) {
                                        return null;
                                    }
                                    const offset = (createdAt.getTime() - sessionStart.getTime()) / 1000;
                                    return { offset, message: msg };
                                })
                                .filter(Boolean)
                                .sort((a, b) => a.offset - b.offset);
                            resetVODChatPlayback();
                            renderVODChatUpTo(player.currentTime || 0);
                            return;
                        }
                    }

                    messages.forEach(msg => appendChatMessage(msg, false));
                    scrollChatToBottom();
                }
            } catch (error) {
                console.warn('Failed to load chat history:', error);
            }
        }

        async function initChat(sessionId) {
            if (!sessionId || chatJoined || chatInitialized) return;
            chatInitialized = true;
            chatSessionId = sessionId;

            try {
                await Chat.connect();
                updateChatStatus('Connecting...', 'connected');
                const token = await getAuthToken();
                if (!token) {
                    updateChatStatus('No valid token', 'error');
                    showError('Could not get valid token, please sign in again');
                    chatInitialized = false;
                    return;
                }
                Chat.authenticate(token);
            } catch (error) {
                console.error('Chat connection error:', error);
                const errorMsg = formatError(error);
                updateChatStatus(`Connection failed: ${errorMsg}`, 'error');
                showError(`Chat server connection failed: ${errorMsg}`);
                chatInitialized = false;
                return;
            }

            Chat.on('auth_result', (msg) => {
                if (msg.success) {
                    updateChatStatus('Authenticated', 'connected');
                    Chat.joinRoom(roomId, chatSessionId);
                } else {
                    const errorMsg = msg.message || msg.error || 'Authentication failed';
                    updateChatStatus(`Auth failed: ${errorMsg}`, 'error');
                    showError(`Chat auth failed: ${errorMsg}`);
                    if (chatReconnectBtn) chatReconnectBtn.disabled = false;
                }
            });

            Chat.on('room_joined', async () => {
                chatJoined = true;
                updateChatStatus('Connected', 'connected');
                if (chatReconnectBtn) chatReconnectBtn.style.display = 'none';
                // VOD replay: no sending messages, only view history
                enableChatInput(!isVOD);
                await loadChatHistory();
            });

            Chat.on('chat_message', (msg) => {
                if (isVOD && vodChatEnabled) {
                    const sessionStart = parseSessionIdToDate(chatSessionId);
                    const createdAt = msg.created_at ? new Date(msg.created_at) : null;
                    if (sessionStart && createdAt && !Number.isNaN(createdAt.getTime())) {
                        const offset = (createdAt.getTime() - sessionStart.getTime()) / 1000;
                        vodChatTimeline.push({ offset, message: msg });
                        vodChatTimeline.sort((a, b) => a.offset - b.offset);
                        return;
                    }
                }
                appendChatMessage(msg);
            });

            Chat.on('error', (msg) => {
                updateChatStatus(`Error: ${msg.message || msg.code}`, 'error');
            });

            Chat.on('disconnected', () => {
                updateChatStatus('Disconnected', 'error');
                enableChatInput(false);
                chatJoined = false;
                if (chatReconnectBtn) {
                    chatReconnectBtn.style.display = chatSessionId ? 'inline-block' : 'none';
                    chatReconnectBtn.disabled = false;
                }
            });
        }

        async function reconnectChat() {
            if (!chatSessionId || !chatReconnectBtn) return;
            chatReconnectBtn.disabled = true;
            updateChatStatus('Reconnecting...', 'connected');
            try {
                Chat.disconnect();
                await Chat.connect();
                const token = await getAuthToken();
                if (!token) {
                    updateChatStatus('No valid token', 'error');
                    chatReconnectBtn.disabled = false;
                    return;
                }
                Chat.authenticate(token);
                Chat.joinRoom(roomId, chatSessionId);
            } catch (err) {
                console.error('Chat reconnect error:', err);
                updateChatStatus('Reconnect failed', 'error');
                chatReconnectBtn.disabled = false;
            }
        }

        function sendChatMessage() {
            const content = chatInputEl.value.trim();
            if (!content) return;
            if (Chat.sendMessage(content)) {
                chatInputEl.value = '';
            }
        }

        // Fetch viewer count via GET presence on entry, avoid WS 0 overwriting
        async function fetchInitialViewerCount() {
            try {
                const res = await fetch(`/api/v1/rooms/${roomId}/presence`, {
                    headers: { ...Auth.getAuthHeader() }
                });
                if (!res.ok) return;
                const data = await res.json();
                const total = data.total != null ? data.total : ((data.authenticated || 0) + (data.anonymous || 0));
                updateViewerCount(total);
            } catch (_) {}
        }

        // Load room info (presence is fetched by fetchInitialViewerCount first)
        async function loadRoom() {
            try {
                const response = await API.rooms.get(roomId);
                const room = response.data;

                document.getElementById('roomTitle').textContent = room.title;
                document.getElementById('ownerName').textContent = room.owner_username;
                document.getElementById('roomDescription').textContent = room.description || 'No description';

                const tagsContainer = document.getElementById('roomTags');
                tagsContainer.innerHTML = (room.tags || [])
                    .map(tag => `<span class="tag">${escapeHtml(tag)}</span>`)
                    .join('');
            } catch (error) {
                showError('Failed to load room: ' + formatError(error));
            }
        }

        // Initialize HLS player
        // isVODMode: if true, disable low latency mode for better VOD playback
        function initPlayer(url, isVODMode = false) {
            if (hls) {
                hls.destroy();
            }

            hlsUrl = url;
            placeholder.style.display = 'none';
            updateInfo('hlsStatus', 'Loading...');

            if (Hls.isSupported()) {
                const hlsConfig = {
                    debug: false,
                    enableWorker: true,
                    backBufferLength: 30,

                    // Fragment (ts segment) retry settings
                    fragLoadingMaxRetry: 6,           // Max retries for segment loading (default: 6)
                    fragLoadingRetryDelay: 500,       // Initial delay before retry (ms)
                    fragLoadingMaxRetryTimeout: 64000, // Max retry timeout (ms)

                    // Manifest (m3u8) retry settings
                    manifestLoadingMaxRetry: 4,       // Max retries for manifest
                    manifestLoadingRetryDelay: 500,   // Initial delay before retry

                    // Level (quality) loading retry
                    levelLoadingMaxRetry: 4,
                    levelLoadingRetryDelay: 500
                };

                // Live mode specific settings
                if (!isVODMode) {
                    hlsConfig.lowLatencyMode = true;
                    hlsConfig.liveSyncDurationCount = 3;         // Start 3 segments behind live edge
                    hlsConfig.liveMaxLatencyDurationCount = 6;   // Max 6 segments behind before seeking
                }

                hls = new Hls(hlsConfig);

                hls.loadSource(url);
                hls.attachMedia(player);

                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    console.log('HLS: Manifest loaded');
                    updateInfo('hlsStatus', 'Connected');
                    setStatus('playing', 'Playing');
                    liveBadge.classList.add('show');
                    isPlaying = true;
                    player.play().catch(e => console.log('Autoplay blocked:', e));
                    startQualityMonitor();
                });

                hls.on(Hls.Events.ERROR, (event, data) => {
                    console.log('HLS error:', data.type, data.details, data.fatal ? '(fatal)' : '(non-fatal)');

                    // Non-fatal errors: HLS.js will auto-retry with our config above
                    if (!data.fatal) {
                        // Log fragment load errors for debugging
                        if (data.details === Hls.ErrorDetails.FRAG_LOAD_ERROR) {
                            console.log('Fragment load failed, will retry automatically');
                        }
                        return;
                    }

                    // Fatal errors need manual recovery
                    switch (data.type) {
                        case Hls.ErrorTypes.NETWORK_ERROR:
                            console.log('Fatal network error, attempting recovery...');
                            if (data.details === Hls.ErrorDetails.MANIFEST_LOAD_ERROR) {
                                // Manifest not found, reinitialize player
                                setTimeout(() => initPlayer(url), 2000);
                            } else {
                                // Try to restart loading
                                hls.startLoad();
                            }
                            break;
                        case Hls.ErrorTypes.MEDIA_ERROR:
                            console.log('Fatal media error, attempting recovery...');
                            hls.recoverMediaError();
                            break;
                        default:
                            console.log('Unrecoverable error, reinitializing player...');
                            setTimeout(() => {
                                hls.destroy();
                                initPlayer(url);
                            }, 2000);
                            break;
                    }
                });

            } else if (player.canPlayType('application/vnd.apple.mpegurl')) {
                // Safari native HLS
                player.src = url;
                player.addEventListener('loadedmetadata', () => {
                    updateInfo('hlsStatus', 'Connected');
                    setStatus('playing', 'Playing');
                    liveBadge.classList.add('show');
                    isPlaying = true;
                    player.play();
                    startQualityMonitor();
                });
            } else {
                showError('Your browser does not support HLS playback');
            }
        }

        function stopPlayer() {
            if (qualityInterval) {
                clearInterval(qualityInterval);
                qualityInterval = null;
            }

            if (hls) {
                hls.destroy();
                hls = null;
            }
            player.src = '';
            placeholder.style.display = 'block';
            isPlaying = false;
            liveBadge.classList.remove('show');
            setStatus('waiting', 'Waiting for stream');
            updateInfo('hlsStatus', 'Waiting');
        }

        // Monitor playback quality (resolution + HLS level bitrate)
        function startQualityMonitor() {
            if (qualityInterval) return;

            qualityInterval = setInterval(() => {
                if (!isPlaying) {
                    clearInterval(qualityInterval);
                    qualityInterval = null;
                    return;
                }

                // Resolution from <video> actual playback size
                const width = player.videoWidth;
                const height = player.videoHeight;
                if (width && height) {
                    updateInfo('playResolution', `${width}x${height}`);
                }

                // Bitrate: from current Hls.js level if available
                if (hls && hls.levels && hls.levels.length > 0 && hls.currentLevel >= 0) {
                    const level = hls.levels[hls.currentLevel];
                    if (level && level.bitrate) {
                        const mbps = (level.bitrate / 1000000).toFixed(2);
                        updateInfo('playBitrate', `${mbps} Mbps`);
                    }
                }
            }, 3000); // Update every 3 seconds
        }

        // Connect to signal server
        async function connectSignal() {
            updateInfo('signalStatus', 'Connecting...');

            try {
                await Signal.connect();
                updateInfo('signalStatus', 'Connected');

                // Use valid token (refresh if expired) to avoid WS auth failure
                const token = await getAuthToken();
                if (!token) {
                    showError('Could not get valid token, please sign in again');
                    return;
                }
                Signal.authenticate(token);

                // Set up event handlers
                Signal.on('auth_result', (msg) => {
                    if (msg.success) {
                        // Join room after auth
                        Signal.joinRoom(roomId);
                    } else {
                        const errorMsg = msg.message || msg.error || 'Authentication failed';
                        updateInfo('signalStatus', `Auth failed: ${errorMsg}`);
                        showError(`Signal server auth failed: ${errorMsg}`);
                    }
                });

                Signal.on('room_joined', (msg) => {
                    console.log('Room joined:', msg);
                    if (msg.viewer_count != null) updateViewerCount(msg.viewer_count);

                    if (msg.is_live && msg.hls_url) {
                        initPlayer(msg.hls_url);
                        const parsedSession = parseSessionIdFromHls(msg.hls_url);
                        if (parsedSession) {
                            initChat(parsedSession);
                        }
                    } else {
                        setStatus('waiting', 'Waiting for stream');
                    }
                });

                Signal.on('stream_available', (msg) => {
                    console.log('Stream available:', msg);
                    if (msg.hls_url) {
                        initPlayer(msg.hls_url);
                        const parsedSession = parseSessionIdFromHls(msg.hls_url);
                        if (parsedSession) {
                            initChat(parsedSession);
                        }
                    }
                });

                // Note: viewer_count is now handled by presence service
                // Signal.on('viewer_count', (msg) => {
                //     updateInfo('viewerCount', msg.count);
                // });

                Signal.on('error', (msg) => {
                    if (msg.code === 'ROOM_NOT_LIVE') {
                        setStatus('waiting', 'Waiting for stream');
                    } else {
                        showError(`Error (${msg.code}): ${msg.message}`);
                    }
                });

                Signal.on('disconnected', () => {
                    updateInfo('signalStatus', 'Disconnected');
                });

            } catch (error) {
                console.error('Signal connection error:', error);
                const errorMsg = formatError(error);
                updateInfo('signalStatus', `Connection failed: ${errorMsg}`);
                showError(`Signal server connection failed: ${errorMsg}`);
            }
        }

        // Connect to presence service for viewer count
        async function connectPresence() {
            try {
                await Presence.connect();

                // Get token for authenticated presence
                const token = await getAuthToken();

                // Join room with authentication
                Presence.joinRoom(roomId, token, null);

                Presence.on('joined', (msg) => {
                    console.log('Presence joined:', msg);
                    if (msg.room_id !== roomId) return;
                    const total = msg.count && (msg.count.total != null ? msg.count.total : (msg.count.authenticated || 0) + (msg.count.anonymous || 0));
                    updateViewerCount(total);
                });

                // WS push: update viewer count on "count" message
                Presence.on('count', (msg) => {
                    if (msg.room_id !== roomId) return;
                    const c = msg.count;
                    const total = c && (c.total != null ? c.total : (c.authenticated || 0) + (c.anonymous || 0));
                    updateViewerCount(total);
                });

                Presence.on('error', (msg) => {
                    console.error('Presence error:', msg.message);
                });

                Presence.on('disconnected', () => {
                    console.log('Presence disconnected');
                });

            } catch (error) {
                console.error('Presence connection error:', error);
            }
        }

        // Initialize: fetch viewer count (GET) first, then load room and connect WS
        (async function init() {
            await fetchInitialViewerCount();
            loadRoom();
            connectPresence();
        })();

        // VOD mode: directly play VOD without signal connection
        if (isVOD && vodSessionId) {
            vodBadge.classList.add('show');
            setStatus('playing', 'VOD');
            placeholder.querySelector('.text').textContent = 'Loading replay...';
            placeholder.querySelector('.subtext').textContent = '';
            const vodUrl = API.media.getVODUrl(roomId, vodSessionId);
            initPlayer(vodUrl, true);
            updateChatStatus('Loading...', 'connected');
            chatInputEl.placeholder = 'Cannot send messages in replay mode';
            chatInputEl.disabled = true;
            chatSendBtn.disabled = true;
            initChat(vodSessionId);
        } else {
            // Live mode: connect to signal server
            connectSignal();
            updateChatStatus('Waiting for stream...', '');
        }

        // Heartbeat
        setInterval(() => {
            if (Signal.ws && Signal.ws.readyState === WebSocket.OPEN) {
                Signal.ping();
            }
        }, 30000);

        // Chat: click status text to reconnect
        chatStatusEl.addEventListener('click', () => {
            if (chatSessionId && !Chat.getState().connected) reconnectChat();
        });
        chatSendBtn.addEventListener('click', sendChatMessage);
        if (chatReconnectBtn) chatReconnectBtn.addEventListener('click', reconnectChat);
        chatInputEl.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendChatMessage();
        });

        // Handle visibility change
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && hls) {
                hls.startLoad();
            }
        });

        // VOD chat playback sync
        player.addEventListener('timeupdate', () => {
            if (isVOD && vodChatEnabled) {
                renderVODChatUpTo(player.currentTime || 0);
            }
        });

        // Cleanup on leave
        window.addEventListener('beforeunload', () => {
            if (roomId) {
                Signal.leaveRoom(roomId);
                Presence.leaveRoom(roomId);
            }
            Signal.disconnect();
            Chat.disconnect();
            Presence.disconnect();
        });
    </script>
</body>
</html>
